using Graphs
using LinearAlgebra

"""
Return the full stabilizer group represented by the input generating set (a [`Stabilizer`](@ref)).

The returned object is exponentially long.

```jldoctest
julia> groupify(S"XZ ZX")
+ __
+ XZ
+ ZX
+ YY
```
"""
function groupify(s::Stabilizer)
    # Create a `Tableau` of 2ⁿ n-qubit identity Pauli operators(where n is the size of 
    # `Stabilizer` s), then multiply each one by a different subset of the elements in s to 
    # create all 2ⁿ unique elements in the group generated by s, then return the `Tableau`.
    gen_set = minimal_generating_set(s)
    n = length(gen_set)::Int
    group = zero(Tableau, 2^n, nqubits(gen_set))
    for i in 0:2^n-1
        for (digit_order, j) in enumerate(digits(i, base=2, pad=n))
            if j == 1
                group[i+1] *= gen_set[digit_order]
            end
        end
    end
    return group
end


"""
For a not-necessarily-minimal generating set,
return the minimal generating set.

The input has to have only real phases.

```jldoctest
julia> minimal_generating_set(S"__ XZ ZX YY")
+ XZ
+ ZX
```
"""
function minimal_generating_set(s::Stabilizer)
    # Canonicalize `Stabilizer` s, then return a `Stabilizer` with all non-identity Pauli operators 
    # in the result. If s consists of only identity operators, return the negative 
    # identity operator if one is contained in s, and the positive identity operator otherwise.
    s, _, r = canonicalize!(copy(s), ranks=true)
    if r == 0
        gs = zero(Stabilizer, 1, nqubits(s))
        if 0x02 in phases(s)
            gs[1] = -1 * gs[1]
        end
        return gs
    else
        return s[1:r, :]
    end
end

"""
For a not-neccessarily commutative set of Paulis, returning a generating set of the form 
<A₁, B₁, A₂, B₂, ... Aₖ, Bₖ, Aₖ₊₁, ... Aₘ> where two operators anticommute if and only if they 
are of the form Aₖ, Bₖ and commute otherwise.

```jldoctest
julia> logical_operator_canonicalize(QuantumClifford.Tableau([P"XX", P"XZ", P"XY"]))
+ XX
+ XZ
-iX_
```
"""
function logical_operator_canonicalize(t:: QuantumClifford.Tableau)
    loc = zero(QuantumClifford.Tableau, length(t), nqubits(t))
    index = 1
    for i in eachindex(t)
        for j in eachindex(t)
            if comm(t[i], t[j]) == 0x01
                for k in eachindex(t)
                    if k !=i && k != j
                        if comm(t[k], t[i]) == 0x01
                            t[k] = t[j] *t[k]
                        end
                        if comm(t[k], t[j]) == 0x01
                            t[k] = t[i] *t[k]
                        end
                    end
                end
                if !(t[i] in loc || -1 *t[i] in loc || 1im *t[i] in loc || -1im * t[i] in loc)
                    loc[index]= t[i]
                    index+=1
                end
                if !(t[j] in loc || -1 *t[j] in loc || 1im *t[j] in loc || -1im * t[j] in loc)
                    loc[index]= t[j]
                    index+=1
                end
            end
        end
    end
    for i in eachindex(t)
        if !(t[i] in loc || -1 *t[i] in loc || 1im *t[i] in loc || -1im * t[i] in loc)
            loc[index]= t[i]
            index+=1
        end
    end
    while length(loc) > 1 && loc[length(loc)-1] == zero(PauliOperator, nqubits(loc)) 
        loc = loc[1:(length(loc)-1)]
    end

    return loc
end

"""
For a not-necessarily commutative set of Paulis, return the logical operator canonical
form of that set, and for each pair Aₖ, Bₖ of anticommutative Paulis, add an X to Aₖ,
a Z to Bₖ, and an I to each other operator, such that the set is now fully commutative 
as well as return a list of the indices of the added qubits.

```jldoctest
julia> embed(QuantumClifford.Tableau([P"XX"]))
+ X_X
+ ZZZ
+ XX_
+ ___

```
"""
function commutavise(t)
    loc = QuantumClifford.logical_operator_canonicalize(t)
    index = -1
    for i in range(1, stop=length(loc), step=2)
        if i + 1 > length(loc) 
            break
        end
        if comm(loc[i], loc[i+1]) == 0x01 
            index = i # index to split loc into non-commuting pairs and commuting operators
        end
    end
    commutative = zero(Stabilizer, length(loc), nqubits(loc)+convert(Int64, (index+1)/2))
    for i in eachindex(loc)
        dummy = commutative[i]
        for j in eachindex(loc[i]) dummy[j] = loc[i][j] end
        commutative[i] = dummy
        
    end
    for i in range(1, stop=length(loc), step=2)
        if (i <= index) 
            dummy = commutative[i]
            dummy[nqubits(t)+convert(Int64, (i+1)/2)] = (true, false) 
            commutative[i] = dummy
            dummy = commutative[i+1]
            dummy[nqubits(t)+convert(Int64, (i+1)/2)] = (false, true) 
            commutative[i+1] = dummy
        end
    end
    to_delete = []
    i = nqubits(t)+1
    while i <=nqubits(t)+convert(Int64, (index+1)/2)
        push!(to_delete, i)
        i+=1
    end
    return commutative, to_delete
end

"""
For a given set of Paulis that does not neccessarily represent a qubit state, return a set of
Paulis that contains the commutativised given set and represents a qubit state. 

```jldoctest
julia> embed(QuantumClifford.Tableau([P"XX"]))
+ X_X
+ ZZZ
+ XX_
+ ___

```
"""
#TODO make more efficent: if have some conditions on way stabilizer is repsented, can do tricks?
# hvae gen set, know its commutative
# norm contains gen set(this case(input is commutative))
# add subsets for contract and delete
function embed(t::QuantumClifford.Tableau)
    com, d1= QuantumClifford.commutavise(t)
    norm = QuantumClifford.normalizer(com.tab)
    state, d2 = QuantumClifford.commutavise(norm)
    return state, d2, d1
end

"""
Return the full Pauli group of a given length. Phases besides + are ignored by default, 
but can be included by setting phases = true.

```jldoctest
julia> pauligroup(1)
+ _
+ X
+ Z
+ Y

julia> pauligroup(1, phases=true)
+ _
+ X
+ Z
+ Y
- _
- X
- Z
- Y
+i_
+iX
+iZ
+iY
-i_
-iX
-iZ
-iY
```
"""
function pauligroup(n::Int; phases=false)
    if phases
        s = zero(Tableau, 4^(n + 1), n)
        paulis = ((false, false), (true, false), (false, true), (true, true))
        for (i, P) in enumerate(Iterators.product(Iterators.repeated(paulis, n)...))
            for (j, p) in enumerate(P)
                s[i, j] = p
            end
        end
        for i in 1:4^n
            s[i+4^n] = -1 * s[i]
        end
        for i in 4^n+1:2*4^n
            s[i+4^n] = -1im * s[i]
        end
        for i in 2*4^n+1:3*4^n
            s[i+4^n] = -1 * s[i]
        end
    end
    if !phases
        s = zero(Tableau, (4^n), n)
        paulis = ((false, false), (true, false), (false, true), (true, true))
        for (i, P) in enumerate(Iterators.product(Iterators.repeated(paulis, n)...))
            for (j, p) in enumerate(P)
                s[i, j] = p
            end
        end
    end
    return s
end

"""
Return all Pauli operators with the same number of qubits as the given `Tableau` `t`
that commute with all operators in `t`.

```jldoctest
julia> normalizer(T"X")
+ _
+ X
```
"""
function normalizer(t::Tableau)
    # For each `PauliOperator` p in the with same number of qubits as the `Stabilizer` s, iterate through s and check each 
    # operator's commutivity with p. If they all commute, add p a vector of `PauliOperators`. Return the vector 
    # converted to `Tableau`.
    n = nqubits(t)
    ptype =typeof(P"I")
    norm = ptype[]

    p = zero(PauliOperator, n)
    paulis = ((false, false), (true, false), (false, true), (true, true))
    for i in Iterators.product(Iterators.repeated(paulis, n)...)
        QuantumClifford.zero!(p)
        for (j, k) in enumerate(i)
            p[j] = k
        end
        commutes = true
        for q in t
            if comm(p, q) == 0x01
                commutes = false
            end
        end
        if commutes
            push!(norm, copy(p))
        end
        # if phases
        #     for phase in [-1, 1im, -1im]   
        #         push!(pgroup, p*phase)
        #     end
        # end
    end
    return QuantumClifford.Tableau(norm)
end

"""
For a given set of Paulis (in the form of a `Tableau`), return the subset of Paulis that commute with all Paulis in set.

```jldoctest
julia> centralizer(T"XX ZZ _Z")
+ ZZ
```
"""
function centralizer(t::Tableau) 
    center = typeof(t[1])[]
    for P in t
        commutes = 0
        for Q in t
            if comm(P, Q) == 0x01
                commutes = 1
                break
            end
        end
        if commutes == 0
            push!(center, P)
        end
    end
    if length(center) == 0 
        return Tableau(zeros(Bool, 1,1))
    end
    c = Tableau(center)
    return c
end

"""
Return the subset of Paulis in a Stabilizer that have identity operators on all qubits corresponding to 
the given subset, without the entries corresponding to subset.

```jldoctest
julia> contractor(S"_X X_", [1])
+ X
```
"""
function contractor(s::Stabilizer, subset)
    result = typeof(s[1])[]
    for p in s
        contractable = true
        for i in subset
            if p[i] != (false, false) 
                contractable = false 
                break 
            end
        end
        if contractable push!(result, p[setdiff(1:length(p), subset)]) end
    end
    if length(result) > 0
        return Tableau(result)
    else
        return Tableau(zeros(Bool, 1,1))
    end
end